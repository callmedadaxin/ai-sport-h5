# 安全性问题清单

本文档列出了项目中可能存在的安全性问题，以及详细的修改方案。

---

## 目录

- [一、XSS 跨站脚本攻击](#一xss-跨站脚本攻击)
- [二、敏感信息泄露](#二敏感信息泄露)
- [三、API 安全](#三api-安全)
- [四、文件上传安全](#四文件上传安全)
- [五、认证授权安全](#五认证授权安全)
- [六、第三方依赖安全](#六第三方依赖安全)
- [七、存储安全](#七存储安全)
- [八、HTTP 安全头配置](#八http-安全头配置)
- [九、其他安全问题](#九其他安全问题)
- [十、安全检查清单](#十安全检查清单)

---

## 一、XSS 跨站脚本攻击

### 1.1 图片 URL 未验证

**问题位置**：`src/views/Home.vue:100`、`src/views/WorkDetail.vue:19`、`src/components/SharePanel.vue:11`

```vue
<img :src="t.cover" :alt="t.title" class="thumb" />
<img :src="detail?.coverUrl" alt="" />
```

**安全风险**：
- 攻击者可能注入 `javascript:` 协议的 URL
- 恶意图片 URL 可能触发 XSS 攻击

**影响的场景**：
- 模板封面图来自用户上传或外部接口
- 分享面板中的图片 URL

**解决方案**：

```javascript
// src/utils/sanitize.js（新建）

/**
 * 验证 URL 是否为安全的图片链接
 * @param {string} url
 * @returns {string} 安全的 URL 或空字符串
 */
export function sanitizeImageUrl(url) {
  if (!url || typeof url !== 'string') return ''

  // 去除前后空格
  url = url.trim()

  // 允许的协议白名单
  const allowedProtocols = ['http:', 'https:', 'data:']
  try {
    const parsedUrl = new URL(url, window.location.origin)
    if (!allowedProtocols.includes(parsedUrl.protocol)) {
      console.warn('[Security] 不允许的协议:', parsedUrl.protocol)
      return ''
    }
  } catch {
    // 相对路径，允许通过
    if (!url.startsWith('//') && !url.includes(':')) {
      return url
    }
    return ''
  }

  // 检查是否为图片类型（仅对 data URL）
  if (url.startsWith('data:') && !url.startsWith('data:image/')) {
    return ''
  }

  return url
}

/**
 * 验证 URL 是否在域名白名单内
 * @param {string} url
 * @param {string[]} allowedDomains
 * @returns {boolean}
 */
export function isAllowedDomain(url, allowedDomains = []) {
  if (!url) return false

  try {
    const parsedUrl = new URL(url, window.location.origin)
    // 相对路径始终允许
    if (!parsedUrl.host) return true

    return allowedDomains.some(domain => {
      return parsedUrl.host === domain || parsedUrl.host.endsWith('.' + domain)
    })
  } catch {
    return false
  }
}
```

**使用方式**：

```vue
<template>
  <img :src="sanitizeImageUrl(t.cover)" :alt="t.title" class="thumb" />
</template>

<script setup>
import { sanitizeImageUrl } from '@/utils/sanitize'
</script>
```

---

### 1.2 路由参数未验证

**问题位置**：`src/views/ShareLanding.vue:73`、`src/views/TemplateDetail.vue`

```javascript
const templateId = detail.value?.templateId || '1'
router.push('/template/' + templateId)
```

**安全风险**：
- 攻击者可能构造恶意 URL 参数
- 可能导致开放重定向

**解决方案**：

```javascript
// src/utils/sanitize.js

/**
 * 验证 ID 是否为有效的数字或字符串
 * @param {string} id
 * @param {string} type - 'number' | 'alphanumeric'
 * @returns {string} 验证后的 ID
 */
export function sanitizeId(id, type = 'alphanumeric') {
  if (!id || typeof id !== 'string') return ''

  const patterns = {
    number: /^[1-9]\d{0,19}$/,           // 纯数字，最大 20 位
    alphanumeric: /^[a-zA-Z0-9_-]{1,64}$/, // 字母数字下划线中划线
    uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
  }

  const pattern = patterns[type]
  if (!pattern) return ''

  const sanitized = id.trim().substring(0, 64)
  return pattern.test(sanitized) ? sanitized : ''
}

/**
 * 安全的 URL 跳转
 * @param {string} path
 * @param {string[]} allowedPrefixes - 允许的路径前缀
 * @returns {string} 安全的路径
 */
export function sanitizeRedirectPath(path, allowedPrefixes = ['/']) {
  if (!path || typeof path !== 'string') return '/'

  // 去除危险字符
  let sanitized = path.trim()

  // 防止协议注入
  if (sanitized.includes('://') || sanitized.startsWith('//')) {
    return '/'
  }

  // 防止 javascript: 协议
  if (sanitized.toLowerCase().startsWith('javascript:')) {
    return '/'
  }

  // 确保以 / 开头
  if (!sanitized.startsWith('/')) {
    sanitized = '/' + sanitized
  }

  // 检查是否在允许的前缀内
  const isAllowed = allowedPrefixes.some(prefix =>
    sanitized.startsWith(prefix)
  )

  return isAllowed ? sanitized : '/'
}
```

---

### 1.3 用户输入未转义

**问题位置**：多处使用用户数据直接显示

**解决方案**：Vue 默认会对文本插值进行转义，但需要注意：

```vue
<template>
  <!-- 安全：Vue 会自动转义 -->
  <p>{{ userInput }}</p>

  <!-- 危险：不要使用 v-html 除非绝对必要 -->
  <!-- <div v-html="userInput"></div> -->

  <!-- 如果必须使用 v-html，先进行清理 -->
  <div v-html="sanitizeHtml(userInput)"></div>
</template>

<script setup>
import DOMPurify from 'dompurify'

function sanitizeHtml(html) {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'span'],
    ALLOWED_ATTR: ['class']
  })
}
</script>
```

---

## 二、敏感信息泄露

### 2.1 Token 存储在 localStorage

**问题位置**：`src/stores/user.js:7-8`

```javascript
const token = ref(localStorage.getItem(STORAGE_KEY + '_token') || '')
const mobile = ref(localStorage.getItem(STORAGE_KEY + '_mobile') || '')
```

**安全风险**：
- XSS 攻击可窃取 localStorage 中的 Token
- 浏览器开发工具可见
- 持久化存储增加了暴露时间

**解决方案**：

```javascript
// src/utils/secureStorage.js（新建）

/**
 * 安全存储工具
 * 方案1：使用 HttpOnly Cookie（推荐，需后端配合）
 * 方案2：使用 sessionStorage + 加密
 * 方案3：使用内存存储 + 短期有效 Token
 */

// 方案2：加密存储示例
const ENCRYPTION_KEY = 'wm_storage_key'

function encrypt(text) {
  if (!text) return ''
  // 简单的 Base64 编码（生产环境应使用 AES 等加密算法）
  try {
    return btoa(encodeURIComponent(text))
  } catch {
    return ''
  }
}

function decrypt(text) {
  if (!text) return ''
  try {
    return decodeURIComponent(atob(text))
  } catch {
    return ''
  }
}

export const secureStorage = {
  setItem(key, value, useSession = false) {
    const storage = useSession ? sessionStorage : sessionStorage // 统一使用 sessionStorage
    const encrypted = encrypt(value)
    storage.setItem(key, encrypted)
  },

  getItem(key, useSession = false) {
    const storage = useSession ? sessionStorage : sessionStorage
    const encrypted = storage.getItem(key)
    return encrypted ? decrypt(encrypted) : ''
  },

  removeItem(key, useSession = false) {
    const storage = useSession ? sessionStorage : sessionStorage
    storage.removeItem(key)
  },

  clear() {
    sessionStorage.clear()
  }
}
```

**修改 user.js**：

```javascript
// src/stores/user.js

import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { secureStorage } from '@/utils/secureStorage'

const STORAGE_KEY = 'wanmei_user'

export const useUserStore = defineStore('user', () => {
  // 使用安全存储
  const token = ref(secureStorage.getItem(STORAGE_KEY + '_token') || '')
  const mobile = ref(secureStorage.getItem(STORAGE_KEY + '_mobile') || '')

  const isLoggedIn = computed(() => !!token.value)

  function setUser(data) {
    token.value = data?.token ?? ''
    mobile.value = data?.mobile ?? ''

    if (token.value) {
      secureStorage.setItem(STORAGE_KEY + '_token', token.value)
      secureStorage.setItem(STORAGE_KEY + '_mobile', mobile.value)
    } else {
      secureStorage.removeItem(STORAGE_KEY + '_token')
      secureStorage.removeItem(STORAGE_KEY + '_mobile')
    }
  }

  function logout() {
    setUser({})
    secureStorage.clear()
  }

  return { token, mobile, isLoggedIn, setUser, logout }
})
```

**最佳方案（需后端配合）**：

```
后端设置 HttpOnly + Secure + SameSite Cookie 存储 Token
前端无需手动管理 Token，浏览器自动携带
```

---

### 2.2 Console 日志泄露

**问题位置**：`src/utils/wechatShare.js:80,104,117,139`、`src/components/SharePanel.vue:214`

```javascript
console.warn('[wechatShare] wx.error', err)
console.log('微信签名', data)
console.log(['schemaUrl', schemaUrl])
console.warn('[wechatShare] setWxShareData failed', e)
```

**安全风险**：
- 生产环境泄露敏感信息
- 可能暴露业务逻辑
- 帮助攻击者了解系统结构

**解决方案**：

```javascript
// src/utils/logger.js（新建）

const isDev = import.meta.env.DEV

export const logger = {
  log(...args) {
    if (isDev) console.log(...args)
  },

  warn(...args) {
    if (isDev) console.warn(...args)
  },

  error(...args) {
    // 错误日志可以考虑上报
    if (isDev) {
      console.error(...args)
    }
    // 生产环境上报错误（可选）
    // reportError(args)
  },

  debug(...args) {
    if (isDev) console.debug(...args)
  },

  // 安全日志：脱敏处理
  safeLog(message, data) {
    if (!isDev) return

    const sanitized = JSON.stringify(data, (key, value) => {
      // 脱敏敏感字段
      const sensitiveKeys = ['token', 'password', 'mobile', 'phone', 'secret', 'key']
      if (sensitiveKeys.some(k => key.toLowerCase().includes(k))) {
        return '***'
      }
      return value
    })

    console.log(message, JSON.parse(sanitized))
  }
}

export default logger
```

**修改 wechatShare.js**：

```javascript
import { logger } from './logger'

// 替换所有 console.log/warn
logger.warn('[wechatShare] wx.error', err)
logger.log('微信签名', data)
```

---

### 2.3 错误信息暴露

**问题位置**：`src/views/Upload.vue:308`、`src/components/SharePanel.vue:168`

```javascript
alert(err?.message || '提交失败')
alert('生成失败')
```

**安全风险**：
- 详细错误信息可能暴露系统内部结构
- 帮助攻击者了解技术栈

**解决方案**：

```javascript
// src/utils/errorHandler.js（新建）

// 错误码映射
const ERROR_MESSAGES = {
  // 网络错误
  NETWORK_ERROR: '网络连接失败，请检查网络后重试',
  TIMEOUT: '请求超时，请稍后重试',

  // 业务错误
  INVALID_PARAMS: '参数错误',
  UNAUTHORIZED: '请先登录',
  FORBIDDEN: '无权限访问',
  NOT_FOUND: '资源不存在',
  SERVER_ERROR: '服务器繁忙，请稍后重试',

  // 文件上传
  FILE_TOO_LARGE: '文件大小超出限制',
  INVALID_FILE_TYPE: '不支持的文件类型',
  UPLOAD_FAILED: '上传失败，请重试',

  // 默认
  UNKNOWN: '操作失败，请重试'
}

/**
 * 安全的错误处理
 * @param {Error|string} error
 * @param {string} fallbackMessage
 * @returns {string} 用户友好的错误信息
 */
export function getSafeErrorMessage(error, fallbackMessage = '操作失败') {
  // 开发环境返回详细错误
  if (import.meta.env.DEV) {
    return error?.message || fallbackMessage
  }

  // 生产环境返回通用错误
  const errorCode = error?.code || error?.response?.data?.code

  if (errorCode && ERROR_MESSAGES[errorCode]) {
    return ERROR_MESSAGES[errorCode]
  }

  // HTTP 状态码
  const status = error?.response?.status
  if (status === 401) return ERROR_MESSAGES.UNAUTHORIZED
  if (status === 403) return ERROR_MESSAGES.FORBIDDEN
  if (status === 404) return ERROR_MESSAGES.NOT_FOUND
  if (status >= 500) return ERROR_MESSAGES.SERVER_ERROR

  return fallbackMessage
}

/**
 * 全局错误处理器
 */
export function setupErrorHandler(app) {
  // Vue 错误
  app.config.errorHandler = (err, vm, info) => {
    logger.error('Vue Error:', err, info)
    // 上报错误
    reportError(err, { type: 'vue', info })
  }

  // 全局 Promise 错误
  window.addEventListener('unhandledrejection', (event) => {
    logger.error('Unhandled Rejection:', event.reason)
    reportError(event.reason, { type: 'unhandledrejection' })
  })

  // 全局 JS 错误
  window.addEventListener('error', (event) => {
    logger.error('Global Error:', event.error)
    reportError(event.error, { type: 'global' })
  })
}

// 错误上报（可选）
function reportError(error, context = {}) {
  // 上报到监控系统
  // fetch('/api/log/error', {
  //   method: 'POST',
  //   body: JSON.stringify({
  //     message: error?.message,
  //     stack: error?.stack,
  //     context,
  //     timestamp: Date.now()
  //   })
  // })
}
```

---

## 三、API 安全

### 3.1 敏感数据传输

**问题位置**：`src/views/Upload.vue:302`

```javascript
worksApi.submit({ templateId: id, image: currentPhoto.value })
```

**安全风险**：
- Base64 图片数据明文传输
- 可能被中间人截获

**解决方案**：

```javascript
// 方案1：使用 HTTPS（必须）
// 确保所有 API 请求都使用 HTTPS

// 方案2：图片使用 FormData 上传
async function submitWithFormData(templateId, imageBase64) {
  // 将 Base64 转为 Blob
  const blob = await fetch(imageBase64).then(r => r.blob())

  const formData = new FormData()
  formData.append('templateId', templateId)
  formData.append('image', blob, 'avatar.jpg')

  return request.post('/works/submit', formData, {
    headers: {
      'Content-Type': 'multipart/form-data'
    }
  })
}

// 方案3：敏感数据加密传输（需后端配合）
import CryptoJS from 'crypto-js'

const SECRET_KEY = 'your-secret-key' // 应从环境变量获取

function encryptData(data) {
  return CryptoJS.AES.encrypt(
    JSON.stringify(data),
    SECRET_KEY
  ).toString()
}

function decryptData(encrypted) {
  const bytes = CryptoJS.AES.decrypt(encrypted, SECRET_KEY)
  return JSON.parse(bytes.toString(CryptoJS.enc.Utf8))
}
```

---

### 3.2 添加请求签名

**问题位置**：`src/api/index.js`

**解决方案**：

```javascript
// src/utils/sign.js（新建）

/**
 * 生成请求签名
 * @param {Object} params
 * @param {string} secret
 * @returns {string}
 */
export function generateSign(params, secret) {
  // 1. 按键名排序
  const sortedKeys = Object.keys(params).sort()

  // 2. 拼接字符串
  const str = sortedKeys
    .filter(key => params[key] !== undefined && params[key] !== '')
    .map(key => `${key}=${params[key]}`)
    .join('&')

  // 3. 加上时间戳和密钥
  const timestamp = Date.now()
  const signStr = `${str}&timestamp=${timestamp}&secret=${secret}`

  // 4. 生成签名
  return {
    timestamp,
    sign: md5(signStr) // 或使用 SHA256
  }
}

// 在请求拦截器中添加签名
request.interceptors.request.use((config) => {
  // ... 原有逻辑

  // 添加签名（仅对 POST/PUT 请求）
  if (['post', 'put', 'delete'].includes(config.method)) {
    const { timestamp, sign } = generateSign(
      config.data || config.params,
      import.meta.env.VITE_API_SECRET
    )
    config.headers['X-Timestamp'] = timestamp
    config.headers['X-Sign'] = sign
  }

  return config
})
```

---

### 3.3 添加请求超时和重试

**解决方案**：

```javascript
// src/api/index.js

const request = axios.create({
  baseURL: '/api',
  timeout: 15000, // 增加到 15 秒
  maxRetries: 2,  // 最大重试次数
  retryDelay: 1000 // 重试间隔
})

// 重试拦截器
request.interceptors.response.use(
  response => response,
  async (error) => {
    const config = error.config

    // 如果配置了重试且未达到最大次数
    if (config && config.maxRetries && config.__retryCount < config.maxRetries) {
      config.__retryCount = config.__retryCount || 0
      config.__retryCount += 1

      // 延迟重试
      await new Promise(resolve =>
        setTimeout(resolve, config.retryDelay || 1000)
      )

      return request(config)
    }

    return Promise.reject(error)
  }
)
```

---

## 四、文件上传安全

### 4.1 文件类型验证

**问题位置**：`src/views/Upload.vue:63-74`

```html
<input type="file" accept="image/*" />
```

**安全风险**：
- accept 属性仅在前端限制，可绕过
- 攻击者可上传恶意文件

**解决方案**：

```javascript
// src/utils/fileValidator.js（新建）

const ALLOWED_MIME_TYPES = [
  'image/jpeg',
  'image/png',
  'image/gif',
  'image/webp'
]

const MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB

// 图片文件头魔数
const FILE_SIGNATURES = {
  'image/jpeg': [0xFF, 0xD8, 0xFF],
  'image/png': [0x89, 0x50, 0x4E, 0x47],
  'image/gif': [0x47, 0x49, 0x46, 0x38],
  'image/webp': [0x52, 0x49, 0x46, 0x46]
}

/**
 * 验证文件类型（通过文件头）
 * @param {File} file
 * @returns {Promise<boolean>}
 */
export async function validateFileType(file) {
  return new Promise((resolve) => {
    const reader = new FileReader()
    reader.onload = (e) => {
      const arr = new Uint8Array(e.target.result)

      // 检查文件头
      const isValid = Object.entries(FILE_SIGNATURES).some(([type, signature]) => {
        return signature.every((byte, index) => arr[index] === byte)
      })

      resolve(isValid)
    }
    reader.onerror = () => resolve(false)
    reader.readAsArrayBuffer(file.slice(0, 8))
  })
}

/**
 * 验证文件大小
 * @param {File} file
 * @param {number} maxSize - 最大字节数
 * @returns {boolean}
 */
export function validateFileSize(file, maxSize = MAX_FILE_SIZE) {
  return file.size > 0 && file.size <= maxSize
}

/**
 * 综合验证文件
 * @param {File} file
 * @returns {Promise<{ valid: boolean, error?: string }>}
 */
export async function validateFile(file) {
  // 检查文件是否存在
  if (!file) {
    return { valid: false, error: '请选择文件' }
  }

  // 检查文件大小
  if (!validateFileSize(file)) {
    return { valid: false, error: '文件大小不能超过 10MB' }
  }

  // 检查 MIME 类型
  if (!ALLOWED_MIME_TYPES.includes(file.type)) {
    return { valid: false, error: '仅支持 JPG、PNG、GIF、WebP 格式' }
  }

  // 检查文件头（防止伪造）
  const isValidType = await validateFileType(file)
  if (!isValidType) {
    return { valid: false, error: '文件格式不正确' }
  }

  return { valid: true }
}
```

**在 Upload.vue 中使用**：

```vue
<script setup>
import { validateFile } from '@/utils/fileValidator'
import { showToast } from '@/utils/toast'

async function onFileSelect(e) {
  const file = e.target.files?.[0]
  if (!file) return

  // 验证文件
  const { valid, error } = await validateFile(file)
  if (!valid) {
    showToast(error)
    e.target.value = ''
    return
  }

  // 继续处理文件
  const reader = new FileReader()
  reader.onload = () => {
    cropImageSrc.value = reader.result
  }
  reader.readAsDataURL(file)
  e.target.value = ''
}
</script>
```

---

### 4.2 图片压缩

**解决方案**：

```javascript
// src/utils/imageCompress.js（新建）

/**
 * 压缩图片
 * @param {File|Blob} file
 * @param {Object} options
 * @returns {Promise<Blob>}
 */
export function compressImage(file, options = {}) {
  const {
    maxWidth = 1024,
    maxHeight = 1024,
    quality = 0.8,
    mimeType = 'image/jpeg'
  } = options

  return new Promise((resolve, reject) => {
    const img = new Image()
    img.onload = () => {
      // 计算缩放比例
      let { width, height } = img
      if (width > maxWidth || height > maxHeight) {
        const ratio = Math.min(maxWidth / width, maxHeight / height)
        width *= ratio
        height *= ratio
      }

      // 创建 canvas
      const canvas = document.createElement('canvas')
      canvas.width = width
      canvas.height = height

      const ctx = canvas.getContext('2d')

      // 图片方向处理（可选，需要 exif-js）
      ctx.drawImage(img, 0, 0, width, height)

      // 导出压缩后的图片
      canvas.toBlob(
        blob => blob ? resolve(blob) : reject(new Error('压缩失败')),
        mimeType,
        quality
      )
    }
    img.onerror = () => reject(new Error('图片加载失败'))
    img.src = URL.createObjectURL(file)
  })
}
```

---

## 五、认证授权安全

### 5.1 Token 刷新机制

**问题位置**：`src/stores/user.js`

**安全风险**：
- Token 无过期时间检查
- 无自动刷新机制

**解决方案**：

```javascript
// src/stores/user.js

import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { authApi } from '@/api'

const TOKEN_EXPIRE_TIME = 2 * 60 * 60 * 1000 // 2小时
const REFRESH_THRESHOLD = 10 * 60 * 1000 // 提前10分钟刷新

export const useUserStore = defineStore('user', () => {
  const token = ref('')
  const mobile = ref('')
  const tokenExpireTime = ref(0)

  const isLoggedIn = computed(() => {
    return !!token.value && Date.now() < tokenExpireTime.value
  })

  function setUser(data) {
    token.value = data?.token ?? ''
    mobile.value = data?.mobile ?? ''
    tokenExpireTime.value = data?.expireTime || (Date.now() + TOKEN_EXPIRE_TIME)

    // 存储到 sessionStorage
    if (token.value) {
      sessionStorage.setItem('user_token', token.value)
      sessionStorage.setItem('user_mobile', mobile.value)
      sessionStorage.setItem('token_expire', String(tokenExpireTime.value))
    } else {
      clearUser()
    }
  }

  function clearUser() {
    token.value = ''
    mobile.value = ''
    tokenExpireTime.value = 0
    sessionStorage.removeItem('user_token')
    sessionStorage.removeItem('user_mobile')
    sessionStorage.removeItem('token_expire')
  }

  function logout() {
    clearUser()
  }

  // 检查并刷新 Token
  async function checkAndRefreshToken() {
    if (!token.value) return false

    const now = Date.now()

    // Token 已过期
    if (now >= tokenExpireTime.value) {
      logout()
      return false
    }

    // 即将过期，尝试刷新
    if (now >= tokenExpireTime.value - REFRESH_THRESHOLD) {
      try {
        const res = await authApi.refreshToken()
        setUser({
          token: res.token,
          mobile: mobile.value,
          expireTime: res.expireTime
        })
        return true
      } catch {
        logout()
        return false
      }
    }

    return true
  }

  // 初始化时恢复状态
  function init() {
    const savedToken = sessionStorage.getItem('user_token')
    const savedMobile = sessionStorage.getItem('user_mobile')
    const savedExpire = sessionStorage.getItem('token_expire')

    if (savedToken && savedExpire) {
      const expireTime = parseInt(savedExpire, 10)
      if (Date.now() < expireTime) {
        token.value = savedToken
        mobile.value = savedMobile || ''
        tokenExpireTime.value = expireTime
      } else {
        clearUser()
      }
    }
  }

  // 自动初始化
  init()

  return {
    token,
    mobile,
    isLoggedIn,
    setUser,
    logout,
    checkAndRefreshToken
  }
})
```

**在 API 拦截器中使用**：

```javascript
// src/api/index.js

import { useUserStore } from '@/stores/user'

request.interceptors.request.use(async (config) => {
  const userStore = useUserStore()

  // 检查并刷新 Token
  const isValid = await userStore.checkAndRefreshToken()

  if (!isValid && !config.url.includes('/auth/')) {
    // Token 无效，跳转登录
    router.push('/')
    return Promise.reject(new Error('Token expired'))
  }

  // 添加 Token
  if (userStore.token) {
    config.headers.Authorization = `Bearer ${userStore.token}`
  }

  return config
})
```

---

### 5.2 权限校验增强

**解决方案**：

```javascript
// src/utils/auth.js（新建）

/**
 * 检查用户权限
 * @param {string|string[]} requiredRoles
 * @returns {boolean}
 */
export function checkPermission(requiredRoles) {
  const userStore = useUserStore()

  if (!userStore.isLoggedIn) {
    return false
  }

  if (!requiredRoles) {
    return true
  }

  const roles = Array.isArray(requiredRoles) ? requiredRoles : [requiredRoles]
  return roles.some(role => userStore.roles?.includes(role))
}

/**
 * 路由守卫
 */
export function setupAuthGuard(router) {
  router.beforeEach((to, from, next) => {
    const userStore = useUserStore()

    // 需要登录的页面
    if (to.meta.requiresAuth && !userStore.isLoggedIn) {
      next({
        path: '/',
        query: { redirect: to.fullPath }
      })
      return
    }

    // 需要特定权限的页面
    if (to.meta.roles) {
      if (!checkPermission(to.meta.roles)) {
        next({ path: '/403' })
        return
      }
    }

    next()
  })
}
```

**在路由中使用**：

```javascript
// src/router/index.js

const routes = [
  {
    path: '/works',
    name: 'Works',
    component: () => import('../views/Works.vue'),
    meta: {
      title: '作品中心',
      requiresAuth: true // 需要登录
    }
  },
  // ...
]
```

---

## 六、第三方依赖安全

### 6.1 外部脚本安全

**问题位置**：`index.html:10-12`

```html
<script src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script>
<script src="https://lf3-static.bytednsdoc.com/obj/eden-cn/fljpeh7hozbf/douyin_open/cdn/dy_open_util_v0.0.6.umd.js"></script>
```

**安全风险**：
- CDN 被劫持可注入恶意代码
- 供应链攻击

**解决方案**：

**方案1：使用 SRI（Subresource Integrity）**

```html
<!-- 添加 integrity 属性 -->
<script
  src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"
  integrity="sha384-xxxxxx"
  crossorigin="anonymous"
></script>
```

**方案2：本地化托管（推荐）**

```javascript
// 1. 下载 SDK 到本地
// public/sdk/jweixin-1.6.0.js
// public/sdk/dy_open_util.js

// 2. 动态加载
// src/utils/sdkLoader.js

export function loadWechatSDK() {
  return new Promise((resolve, reject) => {
    if (window.wx) {
      resolve(window.wx)
      return
    }

    // 非微信环境不加载
    if (!/MicroMessenger/i.test(navigator.userAgent)) {
      resolve(null)
      return
    }

    const script = document.createElement('script')
    script.src = '/sdk/jweixin-1.6.0.js'
    script.onload = () => resolve(window.wx)
    script.onerror = () => reject(new Error('微信 SDK 加载失败'))
    document.head.appendChild(script)
  })
}

export function loadDouyinSDK() {
  return new Promise((resolve, reject) => {
    if (window.dy_open_util) {
      resolve(window.dy_open_util)
      return
    }

    // 非抖音环境不加载
    if (!/Aweme|Douyin/i.test(navigator.userAgent)) {
      resolve(null)
      return
    }

    const script = document.createElement('script')
    script.src = '/sdk/dy_open_util.js'
    script.onload = () => resolve(window.dy_open_util)
    script.onerror = () => reject(new Error('抖音 SDK 加载失败'))
    document.head.appendChild(script)
  })
}
```

---

### 6.2 依赖包安全检查

**解决方案**：

```bash
# 安装安全检查工具
npm install -D npm-audit-resolve

# 运行安全审计
npm audit

# 自动修复
npm audit fix

# 检查已知漏洞
npx better-npm-audit audit
```

**package.json 添加脚本**：

```json
{
  "scripts": {
    "audit": "npm audit --audit-level=moderate",
    "audit:fix": "npm audit fix"
  }
}
```

---

## 七、存储安全

### 7.1 敏感数据处理

**问题位置**：多处使用 sessionStorage 存储数据

```javascript
sessionStorage.setItem('making_avatar', currentPhoto.value)
```

**解决方案**：

```javascript
// src/utils/secureStorage.js

/**
 * 安全的存储封装
 */
class SecureStorage {
  constructor(prefix = 'app_') {
    this.prefix = prefix
  }

  // 敏感字段列表
  static SENSITIVE_KEYS = ['token', 'password', 'secret', 'key', 'mobile']

  // 加密
  encrypt(data) {
    try {
      const json = JSON.stringify(data)
      // 使用 Base64 编码（生产环境应使用 AES 加密）
      return btoa(encodeURIComponent(json))
    } catch {
      return ''
    }
  }

  // 解密
  decrypt(encrypted) {
    try {
      const json = decodeURIComponent(atob(encrypted))
      return JSON.parse(json)
    } catch {
      return null
    }
  }

  set(key, value, expireMs = null) {
    const fullKey = this.prefix + key
    const data = {
      value,
      expire: expireMs ? Date.now() + expireMs : null
    }
    sessionStorage.setItem(fullKey, this.encrypt(data))
  }

  get(key) {
    const fullKey = this.prefix + key
    const encrypted = sessionStorage.getItem(fullKey)
    if (!encrypted) return null

    const data = this.decrypt(encrypted)
    if (!data) return null

    // 检查是否过期
    if (data.expire && Date.now() > data.expire) {
      this.remove(key)
      return null
    }

    return data.value
  }

  remove(key) {
    const fullKey = this.prefix + key
    sessionStorage.removeItem(fullKey)
  }

  clear() {
    const keys = Object.keys(sessionStorage)
    keys.forEach(key => {
      if (key.startsWith(this.prefix)) {
        sessionStorage.removeItem(key)
      }
    })
  }
}

export const secureStorage = new SecureStorage('wm_')
```

---

### 7.2 临时数据清理

**解决方案**：

```javascript
// 在路由变化或页面卸载时清理敏感数据

// src/App.vue
import { onUnmounted } from 'vue'
import { secureStorage } from '@/utils/secureStorage'

onUnmounted(() => {
  // 清理临时数据
  secureStorage.remove('making_avatar')
})

// 或在路由守卫中
router.afterEach((to) => {
  // 离开特定页面时清理
  if (to.meta.clearOnLeave) {
    secureStorage.remove('temp_data')
  }
})
```

---

## 八、HTTP 安全头配置

### 8.1 Nginx 配置

**文件位置**：`nginx/h5.conf`

**解决方案**：

```nginx
server {
    listen 80;
    server_name your-domain.com;

    root /usr/share/nginx/html;
    index index.html;

    # ===== 安全头配置 =====

    # 防止点击劫持
    add_header X-Frame-Options "SAMEORIGIN" always;

    # 防止 MIME 类型嗅探
    add_header X-Content-Type-Options "nosniff" always;

    # XSS 防护
    add_header X-XSS-Protection "1; mode=block" always;

    # 引用策略
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # 权限策略
    add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;

    # 内容安全策略（根据实际情况调整）
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' res.wx.qq.com lf3-static.bytednsdoc.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https:; font-src 'self'; frame-ancestors 'self';" always;

    # HSTS（需要 HTTPS）
    # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # ===== 其他配置 =====

    # Gzip 压缩
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;

    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|webp|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # HTML 不缓存
    location ~* \.html$ {
        expires -1;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
    }

    # API 代理
    location /api/ {
        proxy_pass https://wanmeiyundonghui.jiuzhuokeji.cn/api/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # SPA 路由支持
    location / {
        try_files $uri $uri/ /index.html;
    }
}
```

---

### 8.2 CSP 配置详解

**Content-Security-Policy 配置说明**：

```nginx
# 开发环境（宽松）
add_header Content-Security-Policy "default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:;";

# 生产环境（严格）
add_header Content-Security-Policy "
    default-src 'self';
    script-src 'self' res.wx.qq.com lf3-static.bytednsdoc.com;
    style-src 'self' 'unsafe-inline';
    img-src 'self' data: https:;
    connect-src 'self' https://wanmeiyundonghui.jiuzhuokeji.cn;
    font-src 'self';
    object-src 'none';
    frame-ancestors 'self';
    base-uri 'self';
    form-action 'self';
" always;
```

---

## 九、其他安全问题

### 9.1 点击劫持防护

**解决方案**：

```javascript
// src/main.js

// 检测是否被嵌入 iframe
if (window.self !== window.top) {
  // 被嵌入时跳出
  window.top.location = window.self.location
}

// 或使用 X-Frame-Options 头（已在 Nginx 配置）
```

---

### 9.2 外部链接安全

**解决方案**：

```vue
<template>
  <!-- 外部链接添加 rel="noopener noreferrer" -->
  <a
    href="https://external.com"
    target="_blank"
    rel="noopener noreferrer"
  >
    外部链接
  </a>
</template>
```

---

### 9.3 环境变量安全

**解决方案**：

```javascript
// .env.production
VITE_API_BASE_URL=https://api.example.com
VITE_APP_ENV=production

// 敏感信息不要放在环境变量中
// ❌ VITE_API_SECRET=xxx  会被打包到前端代码
// ✅ 敏感信息应由后端管理

// vite.config.js
export default defineConfig({
  define: {
    // 移除生产环境的敏感信息
    'process.env': JSON.stringify({
      NODE_ENV: JSON.stringify(mode)
    })
  }
})
```

---

## 十、安全检查清单

### 10.1 开发阶段

- [ ] 不在代码中硬编码敏感信息
- [ ] 不使用 `v-html` 或使用前进行清理
- [ ] 验证所有用户输入
- [ ] 使用参数化查询（后端）
- [ ] 实现适当的错误处理

### 10.2 构建阶段

- [ ] 移除 console.log
- [ ] 启用代码压缩和混淆
- [ ] 检查依赖包安全性 (`npm audit`)
- [ ] 配置 CSP 策略

### 10.3 部署阶段

- [ ] 启用 HTTPS
- [ ] 配置安全响应头
- [ ] 禁用目录列表
- [ ] 配置适当的缓存策略

### 10.4 运行阶段

- [ ] 监控异常请求
- [ ] 定期更新依赖
- [ ] 定期进行安全审计
- [ ] 实施日志监控

---

## 问题优先级

| 优先级 | 问题 | 影响程度 | 建议 |
|--------|------|----------|------|
| **紧急** | Token 存储在 localStorage | 高 | 改用 HttpOnly Cookie 或加密存储 |
| **紧急** | 外部脚本无 SRI 验证 | 高 | 本地化或添加 SRI |
| **紧急** | 缺少 CSP 配置 | 高 | 配置 Nginx 安全头 |
| **高** | 文件上传验证不足 | 高 | 添加严格的文件验证 |
| **高** | Console 日志泄露 | 中 | 生产环境移除日志 |
| **高** | Token 无刷新机制 | 中 | 实现自动刷新 |
| **中** | 错误信息暴露 | 中 | 统一错误处理 |
| **中** | URL 参数未验证 | 中 | 添加参数验证 |
| **低** | 点击劫持防护 | 低 | 添加 X-Frame-Options |

---

*文档更新时间：2026-02-27*
